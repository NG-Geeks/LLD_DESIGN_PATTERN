High level Design :: 
class Vehicle {
    string licensePlate;
    VehicleType type;  // CAR, BIKE, TRUCK
};

class Slot {
    int slotId;
    bool isFree;
    VehicleType slotType;   // e.g. BIKE_SLOT, CAR_SLOT
    Vehicle* parkedVehicle; // null if empty
};

class Floor {
    int floorId;
    vector<Slot> slots;
};

class Ticket {
    string ticketId;
    Vehicle vehicle;
    Slot slot;
    time_t entryTime;
};

class ParkingLot {
    vector<Floor> floors;
    
public:
    Ticket parkVehicle(Vehicle v);
    void unparkVehicle(Ticket t);
    void displayFreeSlots(VehicleType type);
};



Low level Design :: 
ParkingLot
- List<ParkingFloor> floors
- String name
- String address
- int totalCapacity
+ addFloor(ParkingFloor)
+ getAvailableSpots(VehicleType): int

ParkingFloor
- List<ParkingSpot> spots
- int floorId
- ParkingDisplayBoard displayBoard
+ getAvailableSpots(VehicleType): int
+ assignSpot(Vehicle): ParkingSpot
+ freeSpot(ParkingSpot)

ParkingSpot
- String spotId
- SpotType type
- boolean isOccupied
- Vehicle vehicle
+ parkVehicle(Vehicle)
+ removeVehicle()
+ canFit(VehicleType): boolean

Vehicle (Abstract)
- String vehicleId
- String licensePlate
- VehicleType type
+ canFitInSpot(SpotType): boolean

ParkingTicket
- String ticketId
- String vehicleId
- String spotId
- Date entryTime
- Date exitTime
- String parkingLotId

ParkingService
- ParkingLotRepository parkingLotRepo
- VehicleRepository vehicleRepo
+ parkVehicle(String parkingLotId, Vehicle): ParkingTicket
+ exitVehicle(String ticketId, BillingService)

BillingService
- BillingRepository billingRepo
+ calculateFee(ParkingTicket): Money
+ processPayment(ParkingTicket, PaymentMethod)

ParkingDisplayBoard
- Map<SpotType, Integer> availableSpots
+ updateAvailableSpots(SpotType, int)





Implmentation  Code ::
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <stdexcept>
#include <ctime>

using namespace std;

// Enums for vehicle and spot types
enum class VehicleType { MOTORCYCLE, CAR, BUS };
enum class SpotType { MOTORCYCLE, COMPACT, LARGE };
enum class PaymentMethod { CASH, CREDIT };

// Forward declarations
class ParkingSpot;
class ParkingFloor;
class ParkingLot;

// Abstract Vehicle class
class Vehicle {
protected:
    string vehicleId;
    string licensePlate;
    VehicleType type;
public:
    Vehicle(string id, string plate, VehicleType t) : vehicleId(id), licensePlate(plate), type(t) {}
    virtual bool canFitInSpot(SpotType spotType) const = 0;
    string getVehicleId() const { return vehicleId; }
    VehicleType getType() const { return type; }
    virtual ~Vehicle() = default;
};

// Concrete vehicle types
class Motorcycle : public Vehicle {
public:
    Motorcycle(string id, string plate) : Vehicle(id, plate, VehicleType::MOTORCYCLE) {}
    bool canFitInSpot(SpotType spotType) const override {
        return true; // Motorcycle can fit in any spot
    }
};

class Car : public Vehicle {
public:
    Car(string id, string plate) : Vehicle(id, plate, VehicleType::CAR) {}
    bool canFitInSpot(SpotType spotType) const override {
        return spotType == SpotType::COMPACT || spotType == SpotType::LARGE;
    }
};

class Bus : public Vehicle {
public:
    Bus(string id, string plate) : Vehicle(id, plate, VehicleType::BUS) {}
    bool canFitInSpot(SpotType spotType) const override {
        return spotType == SpotType::LARGE;
    }
};

// ParkingSpot class
class ParkingSpot {
    string spotId;
    SpotType type;
    bool isOccupied;
    shared_ptr<Vehicle> vehicle;
public:
    ParkingSpot(string id, SpotType t) : spotId(id), type(t), isOccupied(false), vehicle(nullptr) {}
    bool canFit(const shared_ptr<Vehicle>& v) const {
        return !isOccupied && v->canFitInSpot(type);
    }
    void parkVehicle(shared_ptr<Vehicle> v) {
        vehicle = v;
        isOccupied = true;
    }
    void removeVehicle() {
        vehicle = nullptr;
        isOccupied = false;
    }
    string getSpotId() const { return spotId; }
    SpotType getType() const { return type; }
};

// ParkingTicket class
class ParkingTicket {
    string ticketId;
    string vehicleId;
    string spotId;
    time_t entryTime;
    time_t exitTime;
    string parkingLotId;
public:
    ParkingTicket(string tId, string vId, string sId, time_t entry, string lotId)
        : ticketId(tId), vehicleId(vId), spotId(sId), entryTime(entry), parkingLotId(lotId) {}
    string getTicketId() const { return ticketId; }
    string getVehicleId() const { return vehicleId; }
    string getSpotId() const { return spotId; }
    time_t getEntryTime() const { return entryTime; }
    void setExitTime(time_t t) { exitTime = t; }
    time_t getExitTime() const { return exitTime; }
    string getParkingLotId() const { return parkingLotId; }
};

// ParkingFloor class
class ParkingFloor {
    int floorId;
    vector<ParkingSpot> spots;
    map<SpotType, int> availableSpots;
public:
    ParkingFloor(int id, const vector<ParkingSpot>& s) : floorId(id), spots(s) {
        for (const auto& spot : spots) {
            availableSpots[spot.getType()]++;
        }
    }
    ParkingSpot* assignSpot(shared_ptr<Vehicle> vehicle) {
        for (auto& spot : spots) {
            if (spot.canFit(vehicle)) {
                spot.parkVehicle(vehicle);
                availableSpots[spot.getType()]--;
                return &spot;
            }
        }
        return nullptr;
    }
    void freeSpot(const string& spotId) {
        for (auto& spot : spots) {
            if (spot.getSpotId() == spotId) {
                spot.removeVehicle();
                availableSpots[spot.getType()]++;
                break;
            }
        }
    }
    int getAvailableSpots(SpotType type) const {
        return availableSpots.at(type);
    }
};

// ParkingLot class
class ParkingLot {
    string parkingLotId;
    vector<ParkingFloor> floors;
public:
    ParkingLot(string id, const vector<ParkingFloor>& f) : parkingLotId(id), floors(f) {}
    ParkingSpot* findSpot(shared_ptr<Vehicle> vehicle) {
        for (auto& floor : floors) {
            auto spot = floor.assignSpot(vehicle);
            if (spot) return spot;
        }
        return nullptr;
    }
    void freeSpot(const string& spotId) {
        for (auto& floor : floors) {
            floor.freeSpot(spotId);
        }
    }
    string getParkingLotId() const { return parkingLotId; }
};

// BillingService class
class BillingService {
public:
    double calculateFee(const ParkingTicket& ticket) {
        time_t duration = ticket.getExitTime() - ticket.getEntryTime();
        int hours = duration / 3600; // Convert seconds to hours
        if (hours == 0) hours = 1;
        double fee = 0.0;
        if (hours == 1) fee = 4.0; // $4 for first hour
        else if (hours <= 3) fee = 4.0 + (hours - 1) * 3.5; // $3.5 for hours 2-3
        else fee = 4.0 + 2 * 3.5 + (hours - 3) * 2.5; // $2.5 thereafter
        return fee;
    }
    bool processPayment(const ParkingTicket& ticket, PaymentMethod method) {
        double fee = calculateFee(ticket);
        cout << "Processing payment of $" << fee << " via " 
             << (method == PaymentMethod::CASH ? "CASH" : "CREDIT") << endl;
        return true; // Simulate successful payment
    }
};

// ParkingService class
class ParkingService {
    ParkingLot parkingLot;
    map<string, shared_ptr<Vehicle>> vehicles;
public:
    ParkingService(ParkingLot lot) : parkingLot(lot) {}
    ParkingTicket parkVehicle(shared_ptr<Vehicle> vehicle) {
        auto spot = parkingLot.findSpot(vehicle);
        if (!spot) throw runtime_error("No available spot");
        vehicles[vehicle->getVehicleId()] = vehicle;
        return ParkingTicket(to_string(time(nullptr)), vehicle->getVehicleId(), 
                            spot->getSpotId(), time(nullptr), parkingLot.getParkingLotId());
    }
    void exitVehicle(const string& ticketId, BillingService& billingService) {
        // Simulate ticket lookup (in a real system, use a repository)
        ParkingTicket ticket(ticketId, "", "", time(nullptr) - 3600, parkingLot.getParkingLotId());
        ticket.setExitTime(time(nullptr));
        parkingLot.freeSpot(ticket.getSpotId());
        billingService.processPayment(ticket, PaymentMethod::CREDIT);
        vehicles.erase(ticket.getVehicleId());
    }
};

// Main function to test the system
int main() {
    // Initialize parking lot
    vector<ParkingSpot> spots = {
        ParkingSpot("S1", SpotType::MOTORCYCLE),
        ParkingSpot("S2", SpotType::COMPACT),
        ParkingSpot("S3", SpotType::LARGE)
    };
    vector<ParkingFloor> floors = { ParkingFloor(1, spots) };
    ParkingLot parkingLot("LOT1", floors);
    ParkingService parkingService(parkingLot);
    BillingService billingService;

    // Test parking a car
    auto car = make_shared<Car>("V1", "ABC123");
    try {
        ParkingTicket ticket = parkingService.parkVehicle(car);
        cout << "Vehicle parked. Ticket ID: " << ticket.getTicketId() << endl;
        parkingService.exitVehicle(ticket.getTicketId(), billingService);
    } catch (const exception& e) {
        cout << "Error: " << e.what() << endl;
    }

    return 0;
}
