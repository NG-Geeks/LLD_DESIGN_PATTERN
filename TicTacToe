LLD : Design a TicTacToe 



APPROACH 1

#include <iostream>
#include <vector>
#include <string>

class Player {
private:
    std::string name;
    char symbol;

public:
    Player(std::string name, char symbol) : name(name), symbol(symbol) {}
    
    std::string getName() const { return name; }
    char getSymbol() const { return symbol; }
};

class Board {
private:
    std::vector<std::vector<char>> grid;
    const int SIZE = 3;

public:
    Board() {
        grid = std::vector<std::vector<char>>(SIZE, std::vector<char>(SIZE, ' '));
    }

    bool isValidMove(int row, int col) const {
        return row >= 0 && row < SIZE && col >= 0 && col < SIZE && grid[row][col] == ' ';
    }

    bool makeMove(int row, int col, char symbol) {
        if (!isValidMove(row, col)) return false;
        grid[row][col] = symbol;
        return true;
    }

    bool isFull() const {
        for (const auto& row : grid) {
            for (char cell : row) {
                if (cell == ' ') return false;
            }
        }
        return true;
    }

    bool checkWin(char symbol) const {
        // Check rows
        for (int i = 0; i < SIZE; i++) {
            if (grid[i][0] == symbol && grid[i][1] == symbol && grid[i][2] == symbol) return true;
        }
        // Check columns
        for (int j = 0; j < SIZE; j++) {
            if (grid[0][j] == symbol && grid[1][j] == symbol && grid[2][j] == symbol) return true;
        }
        // Check diagonals
        if (grid[0][0] == symbol && grid[1][1] == symbol && grid[2][2] == symbol) return true;
        if (grid[0][2] == symbol && grid[1][1] == symbol && grid[2][0] == symbol) return true;
        return false;
    }

    void display() const {
        std::cout << "\n";
        for (int i = 0; i < SIZE; i++) {
            std::cout << " " << grid[i][0] << " | " << grid[i][1] << " | " << grid[i][2] << "\n";
            if (i < SIZE - 1) std::cout << "---+---+---\n";
        }
        std::cout << "\n";
    }
};

class TicTacToe {
private:
    Board board;
    std::vector<Player> players;
    int currentPlayerIndex;

public:
    TicTacToe(const Player& player1, const Player& player2) : currentPlayerIndex(0) {
        players.push_back(player1);
        players.push_back(player2);
    }

    void play() {
        while (true) {
            board.display();
            Player& currentPlayer = players[currentPlayerIndex];
            std::cout << currentPlayer.getName() << "'s turn (" << currentPlayer.getSymbol() << "): ";
            
            int row, col;
            std::cin >> row >> col;
            
            if (board.makeMove(row, col, currentPlayer.getSymbol())) {
                if (board.checkWin(currentPlayer.getSymbol())) {
                    board.display();
                    std::cout << currentPlayer.getName() << " wins!\n";
                    break;
                }
                if (board.isFull()) {
                    board.display();
                    std::cout << "It's a draw!\n";
                    break;
                }
                currentPlayerIndex = (currentPlayerIndex + 1) % 2;
            } else {
                std::cout << "Invalid move! Try again.\n";
            }
        }
    }
};

int main() {
    Player player1("Player 1", 'X');
    Player player2("Player 2", 'O');
    TicTacToe game(player1, player2);
    std::cout << "Enter moves as 'row col' (0-2 for each, e.g., '1 1' for center):\n";
    game.play();
    return 0;
}





// 2 approach 
#include <iostream>
#include <vector>
#include <string>

class Player {
private:
    std::string name;
    int value; // +1 for Player 1, -1 for Player 2

public:
    Player(std::string name, int value) : name(name), value(value) {}
    
    std::string getName() const { return name; }
    int getValue() const { return value; }
};

class Board {
private:
    std::vector<int> rowSums; // Tracks sum of moves for each row
    std::vector<int> colSums; // Tracks sum of moves for each column
    int diagSum;              // Tracks sum of moves on main diagonal (0,0 to 2,2)
    int antiDiagSum;          // Tracks sum of moves on anti-diagonal (0,2 to 2,0)
    std::vector<std::vector<char>> displayGrid; // For display purposes only
    const int SIZE = 3;
    int moveCount;

public:
    Board() : rowSums(SIZE, 0), colSums(SIZE, 0), diagSum(0), antiDiagSum(0), moveCount(0) {
        displayGrid = std::vector<std::vector<char>>(SIZE, std::vector<char>(SIZE, ' '));
    }

    bool isValidMove(int row, int col) const {
        return row >= 0 && row < SIZE && col >= 0 && col < SIZE && displayGrid[row][col] == ' ';
    }

    bool makeMove(int row, int col, int value, char symbol) {
        if (!isValidMove(row, col)) return false;

        // Update sums
        rowSums[row] += value;
        colSums[col] += value;
        if (row == col) diagSum += value;
        if (row + col == SIZE - 1) antiDiagSum += value;

        // Update display grid
        displayGrid[row][col] = symbol;
        moveCount++;
        return true;
    }

    bool isFull() const {
        return moveCount == SIZE * SIZE;
    }

    bool checkWin(int value) const {
        int winSum = value * SIZE; // +3 for Player 1, -3 for Player 2
        // Check rows
        for (int sum : rowSums) {
            if (sum == winSum) return true;
        }
        // Check columns
        for (int sum : colSums) {
            if (sum == winSum) return true;
        }
        // Check diagonals
        if (diagSum == winSum || antiDiagSum == winSum) return true;
        return false;
    }

    void display() const {
        std::cout << "\n";
        for (int i = 0; i < SIZE; i++) {
            std::cout << " " << displayGrid[i][0] << " | " << displayGrid[i][1] << " | " << displayGrid[i][2] << "\n";
            if (i < SIZE - 1) std::cout << "---+---+---\n";
        }
        std::cout << "\n";
    }
};

class TicTacToe {
private:
    Board board;
    std::vector<Player> players;
    int currentPlayerIndex;

public:
    TicTacToe(const Player& player1, const Player& player2) : currentPlayerIndex(0) {
        players.push_back(player1);
        players.push_back(player2);
    }

    void play() {
        while (true) {
            board.display();
            Player& currentPlayer = players[currentPlayerIndex];
            std::cout << currentPlayer.getName() << "'s turn (" << (currentPlayer.getValue() == 1 ? 'X' : 'O') << "): ";
            
            int row, col;
            std::cin >> row >> col;
            
            char symbol = (currentPlayer.getValue() == 1) ? 'X' : 'O';
            if (board.makeMove(row, col, currentPlayer.getValue(), symbol)) {
                if (board.checkWin(currentPlayer.getValue())) {
                    board.display();
                    std::cout << currentPlayer.getName() << " wins!\n";
                    break;
                }
                if (board.isFull()) {
                    board.display();
                    std::cout << "It's a draw!\n";
                    break;
                }
                currentPlayerIndex = (currentPlayerIndex + 1) % 2;
            } else {
                std::cout << "Invalid move! Try again.\n";
            }
        }
    }
};

int main() {
    Player player1("Player 1", 1);  // +1 for X
    Player player2("Player 2", -1); // -1 for O
    TicTacToe game(player1, player2);
    std::cout << "Enter moves as 'row col' (0-2 for each, e.g., '1 1' for center):\n";
    game.play();
    return 0;
}
